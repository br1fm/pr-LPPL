package constructorast;

import java_cup.runtime.*;
import alex.AnalizadorLexicoTiny;
import alex.UnidadLexica;
import alex.TokenValue;
import errors.GestionErroresTiny;
import ast.*;
import java.util.LinkedList;

scan with {: return getScanner().next_token(); :};
//action code {:
//   ... add some code to declare and initialize e.g. variables used by the code embedded in the grammar
//:};
parser code {: 
   private GestionErroresTiny errores;
   public void syntax_error(Symbol unidadLexica) {
     errores.errorSintactico((UnidadLexica)unidadLexica);
   }
:};
init with {: 
   errores = new GestionErroresTiny();
   AnalizadorLexicoTiny alex = (AnalizadorLexicoTiny)getScanner();
   alex.fijaGestionErrores(errores);
:};


terminal IF, ELSE, TIPO_ENT, TRUE, FALSE, TIPO_BOOL, MAS, IGUAL, IGUALIGUAL, MAYOR, PAP, PCIERRE, CAP, CCIERRE, PUNTOCOMA;
terminal TokenValue IDEN, ENT;


non terminal  LinkedList<Instruccion> P, LInst, ElseCase;
non terminal Instruccion Inst, Cond, Asig, Decl;
non terminal E E0, E1, E2, E3;


P       ::= LInst: l
            {: RESULT = l; :};
            
LInst   ::= Inst: inst LInst: l
            {: l.addFirst(inst);
               RESULT = l;
            :}; 
LInst   ::=  
            {: RESULT = new LinkedList(); :};
            
Inst    ::= Cond: inst
            {: RESULT = inst; :}; 
Inst    ::= Asig: inst
            {: RESULT = inst; :};  
Inst    ::= Decl: inst
            {: RESULT = inst; :};           

Asig    ::= IDEN: id IGUAL E0: exp PUNTOCOMA
            {: RESULT = new Asignacion(id.lexema, exp); :};
            
Decl    ::= TIPO_ENT IDEN: id PUNTOCOMA
            {: RESULT = new Declaracion(Type.NUM, id.lexema); :};
            
Decl    ::= TIPO_BOOL IDEN: id PUNTOCOMA
            {: RESULT = new Declaracion(Type.BOOL, id.lexema); :};
            
Decl    ::= TIPO_HUGE IDEN: id PUNTOCOMA
            {: RESULT = new Declaracion(Type.HUGE, id.lexema); :};
            
Decl    ::= TIPO_HUGEHUGE IDEN: id PUNTOCOMA
            {: RESULT = new Declaracion(Type.HUGEHUGE, id.lexema); :};
            
Cond    ::= IF PAP E0: exp PCIERRE CAP LInst: inst_if CCIERRE ElseCase: inst_else
            {: RESULT = new Condicional(exp, inst_if, inst_else); :};
ElseCase::= ELSE CAP LInst: l CCIERRE
            {: RESULT = l; :};
            
            
E0      ::= E0: op1 MAS E1: op2
            {: RESULT = new EBin(BinOps.MAS, op1, op2); :};  
E0      ::= E1: exp
            {: RESULT = exp; :};
            
E1      ::= E1: op1 MAYOR E2: op2
            {: RESULT = new EBin(BinOps.MAYOR, op1, op2); :};  
E1      ::= E2: exp
            {: RESULT = exp; :};

E2      ::= E2: op1 IGUALIGUAL E3: op2
            {: RESULT = new EBin(BinOps.IGUAL, op1, op2); :};  
E2      ::= E3: exp
            {: RESULT = exp; :};

E3      ::= ENT: value
            {: RESULT = new Num(value.lexema); :};
E3      ::= ENT: value
            {: RESULT = new HugeHuge(value.lexema); :};
E3      ::= ENT: value
            {: RESULT = new Huge(value.lexema); :};      
E3      ::= TRUE
            {: RESULT = new BoolValue("true"); :};
E3      ::= FALSE 
            {: RESULT = new BoolValue("false"); :};
E3      ::= IDEN : id
            {: RESULT = new Identificador(id.lexema); :}; 
E3      ::= PAP E0: exp PCIERRE  
            {: RESULT = exp; :}; 


